This tutorial walks you through the steps of building an OpenCL based design using the SDx GUI and learning some of the features that enable you to do performance profiling and optimization.

This tutorial is based on the Smith-Waterman algorithm, which is a database search algorithm developed by T.F. Smith and M.S. Waterman. It is based on the earlier Needleman and Wunsch algorithm.

<br>

## Preparing to Run the Tutorial
* Using a RDP client, connect to an AWS EC2 instance loaded with the FPGA Developer AMI. Instructions on how to accomplish this are covered in the [Create, configure and test an AWS F1 instance](https://github.com/Xilinx/SDAccel_Examples/wiki/Create,-configure-and-test-an-AWS-F1-instance) guide.
* In a terminal on your AWS instance, execute the following commands to configure the SDAccel environment:   
```
export XILINX_SDX=/opt/Xilinx/SDx/2017.1.op
source $XILINX_SDX/settings64.sh 
```
* Create a new directory and copy over the source files for this tutorial:
```
cd /home/centos
mkdir smithwaterman
cp $XILINX_SDX/examples/getting_started/src/* ./smithwaterman
```   

## Creating an SDAccel Project
In this step, you will launch SDAccel, create a new workspace, load the custom AWS F1 platform definition and create a new project.

* Launch the SDx GUI with the command below. Note that the first invocation of the SDx GUI on a given AWS instance will not be instantaneous but subsequent invocations will be much faster. 
```
sdx
``` 
* In **Workspace Launcher** window, leave **workspace** as the location for your workspace. This is where the project will reside. Click **OK**.
* In the the **SDx Welcome** window, click **Add custom platform** to set the path to AWS F1 platform.
* In the **Hardware Platform Repositories** window, click the green 'plus sign' icon to add a custom platform.
* Browse to the ```/home/centos/src/project_data/aws-fpga/SDAccel/aws_platform/xilinx_aws-vu9p-f1_4ddr-xpr-2pr_4_0``` directory and then click **OK**.
* Click **Apply** and then **OK** to complete the platform setup process.
* Back in the the **SDx Welcome** window, click **Create SDx Project**.
* In the **Create a New SDx project** window in the **Project name** field, type **smithwaterman** and click **Next**.
* In the **Choose Hardware Platform** window choose the **AWS-VU9P-F1 (4ddr-xpr-2pr) (custom)** platform and click **Next**.
* In the **Software Platform and Target CPU** window, the only option for **System configuration** is **Linux on x86** and the only option for **Runtime** is **OpenCL**. Click **Next**.
* The **Templates** window has a list of possible templates that you can use to get started in building an SDAccel project. For this tutorial, select **Empty Application** and click **Finish**.

You have now successfully created a new SDAccel project called **smithwaterman** for the AWS-VU9P-F1 platform. This is prominently displayed in the SDx Project Settings window in the center of the GUI. 

<details>
<summary><strong>Description of the different GUI sections</strong> <i>(expand for details)</i></summary><p>

   * The **main menu** bar is located on the top. This menu bar allows direct access to all general project setup and GUI window management tasks. As most tasks are performed through the different setup windows, the main menu is mostly used to recover from accidentally closed windows or to access the tool help.
   * Directly below the main menu bar is the **SDAccel toolbar**. This provides access to the most common tasks in a project. From left to right, these are: File Management functions (new, save, save all), Configuration Management, Build, Build All, Start Debug, and Run. Most buttons have a default behavior as well as pulldowns.
   * The **Project Explorer** window occupies the top left hand side of the GUI. This window is used to manage and navigate through project files.
   * In the middle is the **SDx Project Settings** window. This window is intended for project management and presents the key aspects of an SDx Project.
   * The **Outline window** on the right hand side is used for file navigation. The content of the outline varies depending on the file currently selected in the main window.
   * In the bottom left section is the **Reports window**. This allows easy access to all reports generated by SDAccel.
   * The remaining windows along the bottom of the main window accommodate the various consoles and terminals which contain output information relating to individual SDAccel executables. Typical output examples are compilation errors or the tool output when running.
<p></details><br>

## Importing Design Files
* In the **Project Explorer** window, expand **smithwaterman > src**. Right-click **src** and select **Import**.
* In the **Import** dialog box, under **General**, select **File System**, and click **Next**.
* In the **Import** dialog box labeled **From directory**, navigate to the ```/home/centos/smithwaterman``` directory created earlier. Click **OK**.
* In the **Import** dialog box, select the following files:
   * kernel.cl
   * main.cpp
   * oclErrorCodes.cpp
   * oclHelper.cpp
   * oclHelper.h
   * soft.cpp
* Click **Finish**.
* You can now expand the **src** directory in the **Project Explorer** to see that all the files are now populated in the project.

## Running Software Emulation
This step shows you how to run SW Emulation of a design, by setting Run Configuration settings, opening reports, and showing how to launch Debug. You can find details on reports and debug in the [SDAccel Environment User Guide, (UG1023)](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_1/ug1023-sdaccel-user-guide.pdf).

* To run CPU Emulation, go to **SDx Project Settings** window and ensure that **Active build configuration** is set to **Emulation-CPU**.
* In the **Hardware Functions** section of the **SDx Project Settings** window, click the **Add Hardware** icon ![](https://github.com/ThomasXilinx/icons/blob/master/AddHW.png). 
* SDAccel analyzes the design for all possible kernels in the design, as well as the ability to filter the list if there are multiple kernels. For this design, only the **smithwaterman** qualified function exists. Ensure that the **smithwaterman** function is selected and click **OK**. This creates a binary container for the kernel, which can be renamed if necessary.
* In the **SDAccel toolbar**, click the **Run** button ![](https://github.com/ThomasXilinx/icons/blob/master/Run.png) to run CPU Emulation. This builds the project and then runs the emulation.
* Take note that the design successfully builds, but the emulation test fails. This can be viewed by looking for **ailed to load kernel** in the **Console** window. Look at the ```main.cpp``` file and notice that there are arguments that need to be provided. The **Run Configurations** field needs to be adjusted to account for these arguments.
* Go to the **Run** menu and select **Run Configurations...** .
* Under the **Arguments** tab you see only the container that holds the kernel as an argument. For this design, you need to set the following arguments: ```-d acc -k ../binary_container_1.xclbin -i 2 -l -1```. Click **Apply**.
   * -d - Specifies what type of device it is. In this case, acc specifies an accelerator.
   * -k - Specifies the kernel to use. If -d is set to acc then this must be a binary file.
   * -i - Specifies the number of iterations to run.
   * -l - Specifies the sequence length to be used in the algorithm default length.
   * -h - List all valid command line switches.
* Still in the **Run Configurations...** window, select the **Profile** tab and make sure both **Generate timeline report** and **Collect device data** are checked. This ensures that analysis reports are generated. 
* Click **Run**. The **Console** window should show **PASSED TEST**. 
> NOTE: If you want to see a verbose output of what the algorithm is doing, go back into **Run Configurations...** and add the **-v** to the arguments (verbose output will start in the terminal window on the next run). 
* After the emulation run is complete, you can look at two reports to design details for further optimization. In the **Reports** window, double-click **Profile Summary**. Here, you can view operations, execution time, bandwidth, and other useful data that you can use to optimize the design. Note that the summary numbers may vary.
* To view the **Application Timeline** report, in the **Reports** window, and double-click **Application Timeline**. This shows a breakdown of the host code and the kernel code, and execution time for each.
* The **Profile Summary** and **Application Timeline** present data on how the host code and kernel communicate and process kernel information. Using the **Debug** feature can help you to step through host-kernel processing to pinpoint issues.
* To run in Debug, you need to set a breakpoint. Setting breakpoints at key points in the execution helps identify problems. From the **Application Timeline**, notice that the API Calls are staggered around the end of the timeline. If you zoom in by clicking and dragging the mouse near the end of the timeline, you can see the fluctuation more easily. Hover the mouse over the **Queue** line above the colored boxes to see information related to the **clEnqueueReadBuffer** transaction and that it is being called multiple times. Set a breakpoint at the main for loop in ```main.cpp``` (line 435), by right-clicking the line number on the line and selecting **Toggle Breakpoint**. This is the loop where **clEnqueueReadBuffer** is executed in the code.
* To run **Debug**, click on the debug icon ![](https://github.com/ThomasXilinx/icons/blob/master/Debug.png). A dialog box opens up asking you to switch to that perspective. Click **Yes**.
* Using Eclipse debugging, the host and kernel code can be examined in more detail. All the controls with which to do step-by-step debugging are in the **Run** menu.
* After you start, Debug stops at the first line of main to be executed (line 484). In the **Runs Configuration** dialog, there is an option to stop on the main function. This is helpful in case of a problematic function in need of more thorough debugging. Press **F8** to resume to the next breakpoint or from the **Run** menu select **Resume**.
* The debugger is now at the ```for loop``` where you set the breakpoint. The run was configured to go through two iterations. Step through the loop while looking at the **Variables** window, and see the variables changing as the stepping occurs.
* Close the **Debug Perspective** by going to the upper-right of the window where it shows the button, right-click and select **Close**.

## Running Hardware Emulation
This step covers running Hardware Emulation feature as well as looking at the basics of profiling and reports.

* To run Hardware Emulation, go to **SDx Project Settings** and make sure that **Active build configuration** is set to **Emulation-HW** then click **Run**. This takes some time to complete.
> NOTE: The main difference between **Emulation-CPU** and **Emulation-HW** is that emulating hardware builds a design that is closer to what is seen on the platform. This means data related to bandwidth, throughput, and execution time are more accurate. The design also takes longer to compile.
* In the **Reports** tab, open **System Estimate**. This is a text report that provides information related to kernel information, timing about the design, clock cycles, and area used in the device.
* In the **Reports** tab, open **Profile Summary**. This summary report provides detailed information related to kernel operation, data transfers, and OpenCL API calls as well as profiling information related to the resource usage, and data transfer to/from the kernel/host. It also provides detailed guidance in how to meet the profile rule checks.
* Scroll to the right in the **Profile Rule Checks** and look for the header column labeled **Guidance**. This is where unmet checks provide some information on how to optimize the kernel.
> NOTE: To see other performance optimization techniques and methodologies, refer to the [SDAccel Performance Optimization Methodology Guide (UG1207)](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_1/ug1207-sdaccel-optimization-guide.pdf).
* Open the **Application Timeline** report. This report shows the estimated time it takes for the host and kernel to complete the task and provides finer grained information on where bottlenecks can be. In this example, it is iterated twice and this timeline shows the kernel is run twice. Adding a marker, zooming, and expanding signals can help in identifying bottlenecks.
* Open the **HLS Report**. This report provides detailed information provided by Vivado HLS on the kernel transformation and synthesis. The tabs at the bottom provide more information on where most of the time is spent in the kernel and other performance related data. Some performance data may include latency and clock period.

## Building to Execute on F1

* To run hardware execution, go to **SDx Project Settings** and set **Active build configuration** to **System**.
* Click the **Build** icon to initiate the hardware build process. 
> IMPORTANT: It generally takes a few hours to complete the hardware build.
* At the end of this process, the host executable (```smithwaterman.exe```) and FPGA binary (```binary_container_1.xclbin```) are generated in the ```/home/centos/workspace/smithwaterman/System``` directory.
* Exit the SDAccel GUI.
* Create the AWS FPGA binary and AFI from the *.xclbin (Xilinx FPGA binary file) using the AWS **create_sdaccel_afi.sh** script:
```
cd /home/centos/workspace/smithwaterman/System
$SDACCEL_DIR/tools/create_sdaccel_afi.sh 
    -xclbin=binary_container_1.xclbin 
    -s3_bucket=<bucket-name> 
    -s3_dcp_key=<dcp-folder-name> 
    -s3_logs_key=<logs-folder-name>
```
* The **create_sdaccel_afi.sh script** does the following:
   * Starts a background process to create the AFI
   * Generates a \<timestamp\>_afi_id.txt which contains the FPGA Image Identifier (or AFI ID) and Global FPGA Image Identifier (or AGFI ID) of the generated AFI
   * Creates the *.awsxclbin AWS FPGA binary file which will need to be read by the host application to determine which AFI should be loaded in the FPGA.
* Note the values of the AFI IDs by opening the \<timestamp\>_afi_id.txt  file
```
cat *.afi_id.txt 
```
* Use the **describe-fpga-images** API to check the status AFI generation process
```
aws ec2 describe-fpga-images --fpga-image-ids <AFI ID>
```
* The AFI creation process started in the background is not instantaneous. You need to make sure that the process completes successfully before being able to run on the F1 instance. When AFI creation completes successfully, the output should contain:
```
...
"State": {
    "Code": "available"
},
...
```
* Wait until the AFI becomes available before proceeding to execute the application on the F1 instance.

## Executing the Application on F1

* Execute the following commands in the instance terminal:
```
cd ..
sudo sh
source /opt/Xilinx/SDx/2017.1.rte/setup.sh   
./smithwaterman.exe
```

## Summary

After completing this tutorial, you should be able to do the following:
* Create an SDAccel project and import the required design files.
* Create a binary container and accelerator for the design.
* Run CPU Emulation and use the Debug environment on host and kernel code.
* Run Hardware Emulation and use the reports to understand possible optimization.
* Understand differences between CPU and Hardware Emulation reports.
* Create an Amazon FPGA Image and execute on F1